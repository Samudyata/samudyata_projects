# -*- coding: utf-8 -*-
"""Datset_Creation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T3dq39k4pfRhy6S0NtKhA_NqzDuK_zbU
"""

!pip install --upgrade --quiet objaverse
!pip install trimesh --quiet

import numpy as np
import objaverse
import trimesh
from pathlib import Path
import os
from tqdm import tqdm
import random

# Ensure directory exists
objaverse_dir = Path.home() / ".objaverse/hf-objaverse-v1/glbs"
objaverse_dir.mkdir(parents=True, exist_ok=True)

lvis_annots = objaverse.load_lvis_annotations()
uuids_vals = list(lvis_annots.values())
uuids = []
for sublist in uuids_vals:
    uuids.extend(sublist)

objects = {}
for uuid in tqdm(uuids[:10], desc="Loading objects"):
    obj = objaverse.load_objects([uuid])
    if obj:
        objects.update(obj)

def create_spaced_holes(
    mesh: trimesh.Trimesh,
    num_holes: int = 3,
    hole_radius_ratio: float = 0.05,
    min_distance_ratio: float = 0.1,
    seed: int = None
) -> trimesh.Trimesh:
    """Create holes in a mesh with comprehensive error handling"""
    # Validate input mesh
    if not isinstance(mesh, trimesh.Trimesh):
        raise ValueError("Input must be a Trimesh object")

    if len(mesh.faces) == 0 or len(mesh.vertices) == 0:
        raise ValueError("Mesh has no faces or vertices")

    # Initialize random seed if provided
    if seed is not None:
        np.random.seed(seed)
        random.seed(seed)

    vertices = mesh.vertices
    faces = mesh.faces

    # Safely compute mesh dimensions
    try:
        bbox = mesh.bounding_box_oriented.bounds
        diag = np.linalg.norm(bbox[1] - bbox[0])
    except:
        # Fallback to axis-aligned bounding box
        bbox = mesh.bounding_box.bounds
        diag = np.linalg.norm(bbox[1] - bbox[0])

    # Handle cases where bounding box calculation fails
    if diag <= 0 or np.isnan(diag) or np.isinf(diag):
        # Use maximum distance between any two vertices
        if len(vertices) > 1:
            pairwise_dists = np.linalg.norm(vertices[:, None] - vertices, axis=2)
            diag = np.max(pairwise_dists)
        else:
            diag = 1.0  # Default size for degenerate meshes

    # Calculate hole parameters
    hole_radius = max(diag * hole_radius_ratio, 1e-6)  # Ensure minimum size
    min_distance = max(diag * min_distance_ratio, 1e-6)

    # Adjust number of holes if mesh is too small
    num_holes = min(num_holes, len(vertices) // 2)
    if num_holes <= 0:
        return mesh  # Return original if no holes can be made

    # Select hole centers
    chosen_indices = []
    candidate_indices = np.arange(len(vertices))
    np.random.shuffle(candidate_indices)

    for idx in candidate_indices:
        if len(chosen_indices) == 0:
            chosen_indices.append(idx)
        else:
            dists = [np.linalg.norm(vertices[idx] - vertices[p]) for p in chosen_indices]
            if all(d > min_distance for d in dists):
                chosen_indices.append(idx)
        if len(chosen_indices) >= num_holes:
            break

    # Create face removal mask
    faces_mask = np.zeros(len(faces), dtype=bool)
    for idx in chosen_indices:
        center = vertices[idx]
        distances = np.linalg.norm(vertices - center, axis=1)
        nearby_verts = np.where(distances < hole_radius)[0]
        if len(nearby_verts) > 0:  # Only proceed if vertices are nearby
            affected_faces = np.any(np.isin(faces, nearby_verts), axis=1)
            faces_mask |= affected_faces

    # Create new mesh (only if we have remaining faces)
    remaining_faces = faces[~faces_mask]
    if len(remaining_faces) > 0:
        new_mesh = trimesh.Trimesh(
            vertices=vertices,
            faces=remaining_faces,
            process=False
        )
        # Preserve visual properties
        if hasattr(mesh.visual, 'vertex_colors'):
            new_mesh.visual.vertex_colors = mesh.visual.vertex_colors
        return new_mesh

    return mesh  # Return original if no faces remain

pip install trimesh[all]

import os
import trimesh

# Create the folder if it doesn't exist
os.makedirs("mesh_holes", exist_ok=True)

for i in range(5):
    scene = trimesh.load(list(objects.values())[i])

    # If it's a scene, flatten it to a single mesh
    if isinstance(scene, trimesh.Scene):
        mesh = scene.to_mesh()
    else:
        mesh = scene
    mesh.show()
    mesh_with_holes = create_spaced_holes(
      mesh,
      num_holes=5,
      hole_radius_ratio=0.03,   # Hole size ~3% of bbox diagonal
      min_distance_ratio=0.1,   # Holes spaced at least 10% of bbox apart
      seed=42)
    mesh_with_holes.show()

    # Save in "mesh_holes" folder
    save_path = os.path.join("mesh_holes", f"mesh_with_holes_{i}.glb")
    mesh_with_holes.export(save_path)